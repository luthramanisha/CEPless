[
  {	"name": "Forward",
    "description": "This operator forwards every item in the data stream.",
    "code": "package operator;\n\npublic class Operator implements OperatorProcessingInterface {\n    //Implement this function to customize your operator\n    @Override\n    public String process(String item) {\n        return item;\n    }\n}"
  },
  {	"name": "K-Means",
    "code": "package operator;\n\nimport com.google.gson.Gson;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\n\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npublic class Operator implements OperatorProcessingInterface {\n\n    static private class KRequest {\n        private int k;\n        private float[][] inputData;\n    }\n\n    @Override\n    public String process(String item) {\n        KRequest request = (new Gson()).fromJson(item, KRequest.class);\n        List<Mean> predicted = predict(request.k, request.inputData);\n        return (new Gson()).toJson(predicted);\n    }\n\n    private final Random mRandomState = new Random();\n    private final int mMaxIterations = 30;\n    private float mSqConvergenceEpsilon = 0.005f;\n\n\n    /**\n     * Runs k-means on the input data (X) trying to find k means.\n     *\n     * K-Means is known for getting stuck into local optima, so you might\n     * want to run it multiple time and argmax on\n     *\n     * @param k The number of points to return.\n     * @param inputData Input data.\n     * @return An array of k Means, each representing a centroid and data points that belong to it.\n     */\n    public List<Mean> predict(final int k, final float[][] inputData) {\n        int dimension = inputData[0].length;\n        final ArrayList<Mean> means = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            Mean m = new Mean(dimension);\n            for (int j = 0; j < dimension; j++) {\n                m.mCentroid[j] = mRandomState.nextFloat();\n            }\n            means.add(m);\n        }\n        // Iterate until we converge or run out of iterationsÃŸ\n        boolean converged = false;\n        for (int i = 0; i < mMaxIterations; i++) {\n            converged = step(means, inputData);\n            if (converged) {\n                break;\n            }\n        }\n        return means;\n    }\n    /**\n     * K-Means iteration.\n     *\n     * @param means Current means\n     * @param inputData Input data\n     * @return True if data set converged\n     */\n    private boolean step(final ArrayList<Mean> means, final float[][] inputData) {\n        // Clean up the previous state because we need to compute\n        // which point belongs to each mean again.\n        for (int i = means.size() - 1; i >= 0; i--) {\n            final Mean mean = means.get(i);\n            mean.mClosestItems.clear();\n        }\n        for (int i = inputData.length - 1; i >= 0; i--) {\n            final float[] current = inputData[i];\n            final Mean nearest = nearestMean(current, means);\n            nearest.mClosestItems.add(current);\n        }\n        boolean converged = true;\n        // Move each mean towards the nearest data set points\n        for (int i = means.size() - 1; i >= 0; i--) {\n            final Mean mean = means.get(i);\n            if (mean.mClosestItems.size() == 0) {\n                continue;\n            }\n            // Compute the new mean centroid:\n            //   1. Sum all all points\n            //   2. Average them\n            final float[] oldCentroid = mean.mCentroid;\n            mean.mCentroid = new float[oldCentroid.length];\n            for (int j = 0; j < mean.mClosestItems.size(); j++) {\n                // Update each centroid component\n                for (int p = 0; p < mean.mCentroid.length; p++) {\n                    mean.mCentroid[p] += mean.mClosestItems.get(j)[p];\n                }\n            }\n            for (int j = 0; j < mean.mCentroid.length; j++) {\n                mean.mCentroid[j] /= mean.mClosestItems.size();\n            }\n            // We converged if the centroid didn't move for any of the means.\n            if (sqDistance(oldCentroid, mean.mCentroid) > mSqConvergenceEpsilon) {\n                converged = false;\n            }\n        }\n        return converged;\n    }\n\n    private static Mean nearestMean(float[] point, List<Mean> means) {\n        Mean nearest = null;\n        float nearestDistance = Float.MAX_VALUE;\n        final int meanCount = means.size();\n        for (int i = 0; i < meanCount; i++) {\n            Mean next = means.get(i);\n            // We don't need the sqrt when comparing distances in euclidean space\n            // because they exist on both sides of the equation and cancel each other out.\n            float nextDistance = sqDistance(point, next.mCentroid);\n            if (nextDistance < nearestDistance) {\n                nearest = next;\n                nearestDistance = nextDistance;\n            }\n        }\n        return nearest;\n    }\n\n    private static float sqDistance(float[] a, float[] b) {\n        float dist = 0;\n        final int length = a.length;\n        for (int i = 0; i < length; i++) {\n            dist += (a[i] - b[i]) * (a[i] - b[i]);\n        }\n        return dist;\n    }\n\n    /**\n     * Definition of a mean, contains a centroid and points on its cluster.\n     */\n    public static class Mean {\n        float[] mCentroid;\n        final ArrayList<float[]> mClosestItems = new ArrayList<>();\n        public Mean(int dimension) {\n            mCentroid = new float[dimension];\n        }\n        public Mean(float ...centroid) {\n            mCentroid = centroid;\n        }\n        public float[] getCentroid() {\n            return mCentroid;\n        }\n        public List<float[]> getItems() {\n            return mClosestItems;\n        }\n        @Override\n        public String toString() {\n            return \"Mean(centroid: \" + Arrays.toString(mCentroid) + \", size: \"\n                    + mClosestItems.size() + \")\";\n        }\n    }\n}\n"
  },
  {	"name": "Fraud Detection",
    "description": "Unusual pattern in the amount to be transferred will be detected and a filter flag is attached to the beginning of each item to indicate if it is fraud or not.",
    "code": "package operator;\r\n\r\npublic class Operator implements OperatorProcessingInterface {\r\n    @Override\r\n    public String process(String item) {\r\n        try {\r\n            String[] parts = item.split(\",\");\r\n            int index = parts[1].indexOf(\".\");\r\n            if (index == -1) {\r\n                index = parts[1].length();\r\n            }\r\n            String number = parts[1].substring(0, index);\r\n            int filter = 0;\r\n            if (Integer.parseInt(number) > 10) {\r\n                filter = 1;\r\n            }\r\n            //  System.out.println(\"Amount \" + parts[1] + \" as Int \" + Integer.parseInt(number) + \" > 50\");\r\n            item = filter + item;\r\n            return item;\r\n        } catch (Exception e) {\r\n\t\t    e.printStackTrace();\r\n\t\t    System.out.println(e);\r\n            System.out.println(e.getMessage());\r\n        }\r\n        return null;\r\n    }\r\n}"
  },
  {	"name": "Sine Function Extension",
    "description": "This operator calculates the sine value of every item from the data stream.",
    "code": "package operator;\n\npublic class Operator implements OperatorProcessingInterface {\n    @Override\n    public String process(String item) {\n\t\tString result = \"\";\n\t\ttry {\n\t\t\tlong input = Long.parseLong(item);\n\t\t\tresult = Math.sin((double) input) + \"\";\n\t\t\treturn result;\n\t\t} catch (NumberFormatException e) {\n\t\t}\n\t\ttry {\n\t\t\tdouble input = Double.parseDouble(item);\n\t\t\tresult = Math.sin((double) input) + \"\";\n\t\t\treturn result;\n\t\t} catch (NumberFormatException e) {\n\t\t}\n\t\treturn null;\n\t}\n}"
  },
  { "name": "Sliding Length Window",
    "description": "This operator simulates the function of a sliding window, where the EVENT_HOLDER list plays the role of a sliding window. For every arriving and expired event, the event is first added to a queue of expired events. Then the EVENT_HOLDER \"slides\" through every events from the EXPIRED_EVENTS queue.",
    "code": "package operator;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class Operator implements OperatorProcessingInterface {\r\n\tprivate int length = 5;\r\n    private static List<String> EVENT_HOLDER = new ArrayList<>();\r\n    /**\r\n     * Custom Sliding Length Window implementation which holds last length events, and gets updated on every event arrival.\r\n     */\r\n    @Override\r\n    public String process(String item) {\r\n        if (EVENT_HOLDER.size() == this.length)\r\n            EVENT_HOLDER.remove(0);\r\n        EVENT_HOLDER.add(item);\r\n        String result = \"\";\r\n        for (int i = 0; i < EVENT_HOLDER.size(); i++) {\r\n            result += EVENT_HOLDER.get(i);\r\n            if (i < EVENT_HOLDER.size() - 1)\r\n                result += \",\";\r\n        }\r\n\t\treturn result;\r\n\t}\r\n}"
  },
  { "name": "Stream Processor",
    "code": "package operator;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\npublic class Operator implements OperatorProcessingInterface {\r\n\tstatic Map<String, Object> map = new HashMap<String, Object>();\r\n    \r\n    @Override\r\n    public String process(String item) {\r\n\t\tList<Object> r = execute(item);\r\n\t\tmap.put(item, r);\r\n\t\treturn item;\r\n\t}\r\n\t\r\n\t//example of event execution\r\n\tprivate List<Object> execute(String values) {\r\n\t\tString[] parts = values.split(\",\");\r\n\t\tList<Object> lst = new ArrayList<>();\r\n\t\tfor(String p : parts) {\r\n\t\t\tlst.add(p);\r\n\t\t}\r\n\t\treturn lst;\r\n\t}\r\n}"
  }
]
